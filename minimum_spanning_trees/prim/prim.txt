*************************************************
Prim's algorithm
*************************************************
- Prim's algorithm maintains two sets of vertices:
    1. Set of vertices already included in the mst.
    2. Set of vertices not yet included.

- Between these two sets there will be cuts, the idea is to pick the smallest one and proceed to add all vertices to the first set until all vertices are included.

- Steps for Prim algorithm:
    - Create a set for the mst to keep track of vertices included in the MST.
    - Give the starting vertex a value of 0 so that it is selected first in the min-priority queue. All other vertices are initialized with a sentinel value of infinity.
    - Keep including vertices if the set for the mst is not full, always pick the smallest weight in the cut.

- During execution of the algorithm, all vertices that are NOT in the tree reside in a min-priority queue Q based on a key attribute.


Prim's algorithm pseudo code
-------------------------------------------------
#DEFINE G = (V, E)  // Graph G with sets of vertices V and edges E
#DEFINE w           // weight function for edge (u, v)
#DEFINE r           // root vertex (where you start from)
#DEFINE MAX         // max value of an integer allowed in hardware

MST_PRIM(G, w, r)
    for each u that exists in G.V
        u.key = MAX
        u.predecessor = NULL
    r.key = 0
    min queue Q = G.V
    while !Q.isEmpty()
        u = EXTRACT_MIN(Q)
        for each v that exists in G.Adj[u]
            if v exists in Q and w(u, v) < v.key
                v.predecessor = u
                v.key = w(u, v)


- The running time of Prim's algorithm depends on how we implement the min-priority queue Q.
- The total time for Prim's algorithm is O(V*lgV + E*lgE) = O(E*lgV), which is asymptotically the same as for the implementation of Kruskal's algorithm.
