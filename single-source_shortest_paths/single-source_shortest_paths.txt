*************************************************
Single-source shortest paths
*************************************************
- Continuing with graph theory, the single-source shortest paths problem tries to find the path between two vertices that has the least cost.

- Formally, we are given a weighted, directed graph G =(V, E), with weight function w that maps edges to real-valued weights.
    - The weight of a path p is the sum of the weights of its constituent edges. 
    * The shortest-path weight, denoted Delta(u, v), from u to v is defined as the minimum value of any path, if one exists, from u to v. 
        - A shortest path from vertex u to vertex v is then defined as any path p with weight w(p) = Delta(u, v).
    
- Examples of edge representations: road distance, time, cost, penalties, loss, etc.


- A subpath of a shortest path is a shortest path.
    - Can use cut and paste to prove this (as you already have an absolute shortest path).


- The algorithms discussed in this topic can also be applied to variants of this problem:
    * Single-destination shortest-paths problem: find a shortest path to a given destination vertex from any vertex. Reversing all directions gives us single-source shortest paths.
    
    * Single-pair shortest-path problem: find the shortest path between two given vertices. Can solve single-source problem (starting at one of the vertices) to solve this also.
    
    * All-pairs shortest-paths problem: find a shortest path from u to v for every pair of vertices. This problem is described in more detail in its own directory.

    
- If there are negative-weight edges in the graph, shortest paths may not exist. Let s be the source vertex.
    - If you find a negative cycle that is reachable from s, that is, a cycle whose total weight ends up being negative, you will NOT have a shortest path since you can go around this cycle more and more times. You "artificially decrease" the weight down to negative infinity.
    - There can be negative-weight edges, however, so long as there are no cycles; this also applies to positive-edged cycles.
    
- There can also be no paths if the graph is empty.


* Relaxing a vertex
    - We maintain the attribute v.d--the shortest-path value from some source vertex to v. In order for the algorithms discussed here to work, we must initialize all other vertices to infinity with null predecessors.
    
    
    Intialize vertices pseudo code
    ---------------------------------------------    
    #DEFINE MAX // max value possible in hardware
    
    INITIALIZE_SINGLE_SOURCE(G, s)
        for each vertex v that exists in G.V
            v.d = MAX
            v.predecessor = NULL
        s.d = 0 // distance from source to source is zero
    
    
    - Starting from a source vertex s (to destination v), the process of "relaxing" some edge (u, v) means testing if including vertex u will give us the shortest path.
        - We obviously want the smaller value, so update v.d to be that.
        - For this I suggest working out the algorithms to see the effects of relaxing.
    
    
    Relaxation pseudo code on edge (u, v)
    ---------------------------------------------
    RELAX(u, v, w)
        if v.d > u.d + w(u, w)
            v.d = v.d + w(u, v)
            v.predecessor = u

