*************************************************
Bellman-Ford algorithm
*************************************************
- The Bellman-Ford algorithm solves the single-source shortest paths problem in the general case in which edge weights may be negative. The pseudo code provided returns a boolean value, it will be false if a negative-weight cycle exists, otherwise it will return true and produce the shortest paths and their weights.

* A formal explanation: The algorithm relaxes edges, progressively decreasing an estimate v.d on the weight of a shortest path from the source s to each vertex until it achieves the actual shortest-path weight. The algorithm goes through the entire set of edges |V| - 1 times, relaxing and storing minimum weights if they exist. If no changes are made to the d values after one iteration, we can stop the algorithm as more iterations will just update nothing--the shortest paths have already been calculated.
    - However, if we continue to update weights after |V| times, this is bad; we have a cycle somewhere whose total weight is negative.
    
* My explanation:
    - 


Bellman-Ford algorithm pseudo code
-------------------------------------------------
#DEFINE w   // weight function for edge (u, v)

BELLMAN_FORD(G, w, s)
    INITIALIZE_SINGLE_SOURCE(G, s)
    for i = 1 to |G.V| - 1
        for each edge (u, v) that exist in G.E
            RELAX(u, v, w)
    for each edge (u, v) that exist in G.E
        if v.d > u.d + w(u, v)
            return FALSE
    return TRUE
    

- This algorithm runs in time O(VE), since initializing takes Theta(V) time, the first for loop takes Theta(E), and the second O(E) time.
