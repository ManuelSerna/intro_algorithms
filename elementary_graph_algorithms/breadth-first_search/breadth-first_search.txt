//***********************************************
 Breadth-first search notes.
//***********************************************

- Given a graph G = (V, E) and a distinguished source vertex s, breadth-first search systematically explores the edges of G to "discover" every vertex that is reachable from s. 
- It computes the distance (smallest number of edges) from s to each reachable vertex. 

- It also produces a "breadth-first tree" with s being the root, and the root's descendants are all the reachable vertices. 

- This algorithm works for directed and undirected graphs.

To keep track of progress, breadth-first search colors each vertex:
    - White vertex:
        All vertices are initially white, this color means "undiscovered".
    
    When a vertex is discovered, it becomes nonwhite, 
    gray and black colors mean a certain node has been discovered already.
    
    If (u, v) exist in E...
    - Gray vertex:
        May have some adjacent white vertices, these can represent the "frontier" between discovered and undiscovered vertices.
    
    - Black vertex:
        If vertex u is black, then vertex v is either gray or black; 
        that is, all vertices adjacent to black vertices have been discovered


The pseudo code for BFS assumes that the input graph G = (V, E) is represented using adjacency lists. 
Color for a vertex u is stored in u.color and the predecessor in u.p (NULL if there is no predecessor).
The attribute u.d holds the distance from the source s to vertex u computed by the algorithm, 
and this procedure uses a queue to manage gray vertices.

Note: this procedure is used to find the shortest path distances between two vertices.

//-----------------------------------------------
 BFS pseudo code
//-----------------------------------------------
#DEFINE MAX // max number supported by hardware
#DEFINE s   // source (starting) vertex when procedure first starts

// Note: some set notation used
BFS(G, s)
    // Vertex u from the set of vertices not including source vertex
    for each vertex u that exists in {G.V - {s}}
        u.color = "white"
        u.d = MAX
        u.predecessor = NULL
        
    // source vertex starts out gray (as we still need to explore adjacent vertices) and start at time = 0
    s.color = "gray"
    s.d = 0
    s.predecessor = NULL
    
    // Create a queue structure and insert s into it, note that it wil be removed in the first line of the while loop.
    Q = empty queue
    ENQUEUE(Q, s)
    
    // If s is the only vertex in V, then we exit the while loop.
    while Q is not empty
        u = DEQUEUE(Q)
        // Look at each adjacent vertex of u
        for each v that exists in G.Adj[u]
            if v.color == "white"
                v.color = "gray"    // discovered vertex is gray now
                v.d = u.d + 1       // add one unit of time from "parent" node u...
                v.predecessor = u   // ...and label u as such
                ENQUEUE(Q, v)       // queue adjacent vertex v so we can search it later
        u.color = "black"           // when all adjacent vertices have been discovered, we're done, color this vertex u black
