*************************************************
Depth-first search
*************************************************
- The objective of the depth-first strategy is to go as deep into the graph as possible, and then backtrack.

* Basic steps:
    - Depth-first explores edges out of the most recently discovered vertex v that still has unexplored edges leaving it.
    - Once all of v's edges have been explored, the search "backtracks" to explore edges leaving from which v was discovered, then continue until all vertices connected to source vertex.
    - If there are vertices yet to be discovered, the algorithm selects one as a new source and repeats this traversal process.

* Vertices are colored:
    - White: every vertex originally white, "undiscovered"
    - Gray: "discovered" vertex during search
    - Black: vertex blackened when finished (when adjacency list as been examined completely)
    
    This guarantees that each vertex ends up exactly once spanning tree if searching from mutliple source vertices

* Attributes of a vertex v
    - d: records when v was first discovered and grayed
    - f: records when search finishes examining v's adjacency list and blackens v
    
    v.d < v.f
    
    Vertex u is white before u.d, gray between time u.d and u.f, and black thereafter.
    
- Run time of BFS and DFS: Theta(V + E)

- Note: this algorithm is mostly used as a subroutine in other algorithms.
    Graph G can be directed or undirected, with time being a global variable.


DFS pseudo code
-------------------------------------------------
#DEFINE time // system time

// Using recursion
DFS(G)
    for each vertex u that exists in G.V
        u.color = "white"
        u.predecessor = NULL
    time = 0
    for each vertex u that exists in G.V
        if u.color == "white"
            DFS_VISIT(G, u)

DFS_VISIT(G, u)
    time = time + 1         // white vertex u has just been discovered
    u.d = time
    u.color = "gray"
    for each v that exists in G.Adj[u]  // explore edge (u, v)
        if v.color == "white"
            v.predecessor = u
            DFS_VISIT(G, v)
    u.color = "black"       // blacken u; it is finished
    time = time + 1
    u.f = time


DFS procedure that uses a stack instead of recursion
-------------------------------------------------
// Same initial call
DFS(G)
    // Each vertex starts off as white
    for each vertex u that exists in G.V
        u.color = "white"
        u.p = NULL
    for each u that exists in G.V
        if u.color == "white"
            DFS_VISIT_STACK(G, u)   // use stack, not recursion

DFS_VISIT_STACK_VERSION(G, u)
    S = empty stack
    S.push(u)
    while stack is not empty
        x = S.pop()
        if x.color == "white"
            time = time + 1
            x.color = "gray"
            S.push(x)       // store x in stack to keep track of backtracing
            for each v in x.adjacent()
                if v.color == "white"
                    v.predecessor = x
                    stack.push(v)
        else if x.color == "gray"
            time = time + 1
            x.f = time
            x.color = "black"


Print front, cross, and back edges that form from the DFS spanning tree
-------------------------------------------------
DFS_VISIT_PRINT(G, u)
    time = time + 1
    u.d = time
    u.color = "gray"
    for each v that exists in G.Adj[u]
        if v.color == "white"
            print "(u, v) is a tree edge."
            v.predecessor = u
            DFS_VISIT_PRINT(G, v)
        else if v.color == "gray"
            print "(u, v) is a back edge."
        else
            if v.d > u.d
                print "(u, v) is a forward edge."
            else 
                print "(u, v) is a cross edge."



- For edge classifications (see scanned doc for a more visual presentation)

- When tracing the traversal of a depth-first search on a graph, for a particular traversal sequence, you have a depth-first spanning tree.
    - In these spanning trees, the source vertex s is the root, 
    and then its descendants are the vertices pushed to the stack in order at which they were pushed.

* Classifications:
    - Tree edges: 
        These are the "normal" lines connecting consecutive vertices, no skipping or jumping around branches.
        You get these when, from u, you discover v (make edge (u, v)).

    - Back edges: 
        A vertex u is not a direct descendant of some ancestor vertex v, u points up to v, skipping at least one vertex.
        The book considers loops (occur in directed graphs) to be back edges.
            - Back edges indicate cycles in the original graph.

    - Forward edges:
        A vertex v is a descendant of and is connected to vertex u, but u and v do not make an edge.
        
    - Cross edges:
        "All other edges", meaning one vertex cannot be the descendant of the other.
        ex: two vertices connected across two branches.
