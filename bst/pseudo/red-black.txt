//*********************************************** 
 Red-Black Tree pseudocode.
//***********************************************

/*
- A red-black tree is a binary search tree that satisfies the
red-black properties.

    i.   Every node is either red or black.

    ii.  The root is black

    iii. Every leaf (NIL) is black.
        - the leafs are nodes with nothing.

    iv.  If a node is red, then both its children are black.
        - Implies red nodes are NEVER connected.

    v.   For each node, all simple paths from the node to descendant
    leaves contain the same number of black nodes.

- A red-black tree with n internal nodes has height at most 2 * lg(n + 1)
    
- Can the dynamic-set operations SEARCH, MINIMUM, MAXIMUM, SUCCESSOR, and PREDECESSOR
in O(lg n ) time on red-black trees, since each can run in O(h) time on a regular bst
of height h.
*/

//===============================================
 Rotation.
//===============================================

    |         LEFT_ROTATE(T, x)          |
    y         <----------------          x
   / \                                  / \
  x   C                                A   y
 / \          ---------------->           / \
A   B         RIGHT_ROTATE(T, y)         B   C

// *Notice that only the subtree B changes parent nodes, A will always be the left subtree of x while C will always be the right subtree of y.
//-----------------------------------------------
 Left rotate pn x.
//-----------------------------------------------
LEFT_ROTATE(T, x)
    y = x.right         // set y to be x's right child
    x.right = y.left    // turn y's left subtree (B) into x's right subtree (subtree B)
    
    if y.left != T.nil  // if B is a populated subtree, have x point to y
        y.left.p = x
    y.p = x.p           // link x's parent to y
    
    if x.p == T.nil     // Make y the new root if x was the root
        T.root = y
    else if x == x.p.left 
        x.p.left = y    // make x the left child of y
    else
        x.p.right = y   // make x the right child of y
    
    y.left = x          // put x on y's left
    x.p = y


//-----------------------------------------------
 Right rotate on y.
//-----------------------------------------------
RIGHT_ROTATE(T, y)
    x = y.left          // set x to be y's right child
    y.left = x.right    // turn x's left subtree B into y's right subtree
    
    if x.right != T.nil // if B is a populated subtree, have y point to x
        x.right.p = y
    x.p = y.p           // link x's parent to y
    
    if y.p == T.nil     // Make x the new root if y was the root
        T.root = x
    else if y == y.p.right
        y.p.right = x   // make y the right child of x
    else
        y.p.left = x    // make x the left child of y
    
    x.right = y         // put y on x's right
    y.p = x


//===============================================
 Insert.
/*
    Strategy:
        i) insert node z and color it red
        ii) recolor and rotate nodes to fix violation(s)
    
    Four cases:
        0) z is the root
        1) z's uncle y is red
        2) z's uncle y is black and z is a right child
        3) z's uncle y is black and z is a left child
*/
//===============================================
RB_INSERT(T, z)
    y = T.nil
    x = T.root

    // search the rb tree to insert z
    while x != T.nil
        y = x               // y will be x's (then z's) parent
        if z.key < x.key
            x = x.left
        else
            x = x.right
    z.p = y
    
    if y == T.nil           // the rb tree was empty (case 0)
        T.root = z
    else if z.key < y.key
        y.left = z          // insert left
    else
        y.right = z         // insert right
    
    // Properly assign z's NIL nodes, and always color the node red
    z.left = T.nil
    z.right = T.nil
    z.color = RED
    RB_INSERT_FIXUP(T, z)   // maintain red-black properties

//-----------------------------------------------
 Auxillary procedure that will recolor nodes and perform rotations.
//-----------------------------------------------
RB_INSERT_FIXUP(T, z)
    while z.p.color == RED
        if z.p == z.p.p.left
            y = z.p.p.right      // y is z's grandfather
            if y.color == RED
                z.p.color = BLACK   // case 1
                y.color = BLAXK     // case 1
                z.p.p.color = RED   // case 1
                z = z.p.p           // case 1
            else if z == z.p.right
                    z = z.p             // case 2
                    LEFT_ROTATE(T, z)   // case 2
                z.p.color = BLACK       // case 3
                z.p.p.color = RED       // case 3
                RIGHT_ROTATE(T, z)      // case 3
        else
            y = z.p.p.left      // y is z's grandfather
            if y.color == RED
                z.p.color = BLACK   // case 1
                y.color = BLAXK     // case 1
                z.p.p.color = RED   // case 1
                z = z.p.p           // case 1
            else if z == z.p.left
                    z = z.p             // case 2
                    RIGHT_ROTATE(T, z)  // case 2
                z.p.color = BLACK       // case 3
                z.p.p.color = RED       // case 3
                LEFT_ROTATE(T, z)       // case 3
    
    T.root.color = BLACK        // root is black (case 0)


//===============================================
 Transplant for red-black trees.
//===============================================
TODO: write code for transplant

//===============================================
 Delete.
//===============================================
TODO: write code for delete
TODO: write code for delete fixup
