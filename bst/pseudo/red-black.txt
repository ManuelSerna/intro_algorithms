//*********************************************** 
 Red-Black Tree pseudocode.
//***********************************************

/*
- A red-black tree is a binary search tree that satisfies the
red-black properties.

    i.   Every node is either red or black.

    ii.  The root is black

    iii. Every leaf (NIL) is black.
        - the leafs are nodes with nothing.

    iv.  If a node is red, then both its children are black.
        - Implies red nodes are NEVER connected.

    v.   For each node, all simple paths from the node to descendant
    leaves contain the same number of black nodes.

- A red-black tree with n internal nodes has height at most 2 * lg(n + 1)
    
- Can the dynamic-set operations SEARCH, MINIMUM, MAXIMUM, SUCCESSOR, and PREDECESSOR
in O(lg n ) time on red-black trees, since each can run in O(h) time on a regular bst
of height h.
*/


//===============================================
 Find minimum of a subtree.
//===============================================
TREE_MINIMUM(x)
    while x.left != NULL
        x = x.left
    return x

//===============================================
 Rotation.
//===============================================

    |         LEFT_ROTATE(T, x)          |
    y         <----------------          x
   / \                                  / \
  x   C                                A   y
 / \          ---------------->           / \
A   B         RIGHT_ROTATE(T, y)         B   C

// *Notice that only the subtree B changes parent nodes, A will always be the left subtree of x while C will always be the right subtree of y.
//-----------------------------------------------
 Left rotate pn x.
//-----------------------------------------------
LEFT_ROTATE(T, x)
    y = x.right         // set y to be x's right child
    x.right = y.left    // turn y's left subtree (B) into x's right subtree (subtree B)
    
    if y.left != T.nil  // if B is a populated subtree, have x point to y
        y.left.p = x
    y.p = x.p           // link x's parent to y
    
    if x.p == T.nil     // Make y the new root if x was the root
        T.root = y
    else if x == x.p.left 
        x.p.left = y    // make x the left child of y
    else
        x.p.right = y   // make x the right child of y
    
    y.left = x          // put x on y's left
    x.p = y


//-----------------------------------------------
 Right rotate on y.
//-----------------------------------------------
RIGHT_ROTATE(T, y)
    x = y.left          // set x to be y's right child
    y.left = x.right    // turn x's left subtree B into y's right subtree
    
    if x.right != T.nil // if B is a populated subtree, have y point to x
        x.right.p = y
    x.p = y.p           // link x's parent to y
    
    if y.p == T.nil     // Make x the new root if y was the root
        T.root = x
    else if y == y.p.right
        y.p.right = x   // make y the right child of x
    else
        y.p.left = x    // make x the left child of y
    
    x.right = y         // put y on x's right
    y.p = x


//===============================================
 Insert.
/*
    Strategy:
        i) insert node z and color it red
        ii) recolor and rotate nodes to fix violation(s)
    
    Four cases:
        0) z is the root
        1) z's uncle y is red
        2) z's uncle y is black and z is a right child
        3) z's uncle y is black and z is a left child
*/
//===============================================
RB_INSERT(T, z)
    y = T.nil
    x = T.root

    // search the rb tree to insert z
    while x != T.nil
        y = x               // y will be x's (then z's) parent
        if z.key < x.key
            x = x.left
        else
            x = x.right
    z.p = y
    
    if y == T.nil           // the rb tree was empty (case 0)
        T.root = z
    else if z.key < y.key
        y.left = z          // insert left
    else
        y.right = z         // insert right
    
    // Properly assign z's NIL nodes, and always color the node red
    z.left = T.nil
    z.right = T.nil
    z.color = RED
    RB_INSERT_FIXUP(T, z)   // maintain red-black properties

//-----------------------------------------------
 Auxillary procedure that will recolor nodes and perform rotations.
//-----------------------------------------------
RB_INSERT_FIXUP(T, z)
    while z.p.color == RED
        if z.p == z.p.p.left
            y = z.p.p.right             // y is z's grandfather
            if y.color == RED
                z.p.color = BLACK       // case 1
                y.color = BLAXK         // case 1
                z.p.p.color = RED       // case 1
                z = z.p.p               // case 1
            else if z == z.p.right
                    z = z.p             // case 2
                    LEFT_ROTATE(T, z)   // case 2
                z.p.color = BLACK       // case 3
                z.p.p.color = RED       // case 3
                RIGHT_ROTATE(T, z)      // case 3
        else
            y = z.p.p.left              // y is z's grandfather
            if y.color == RED
                z.p.color = BLACK       // case 1
                y.color = BLAXK         // case 1
                z.p.p.color = RED       // case 1
                z = z.p.p               // case 1
            else if z == z.p.left
                    z = z.p             // case 2
                    RIGHT_ROTATE(T, z)  // case 2
                z.p.color = BLACK       // case 3
                z.p.p.color = RED       // case 3
                LEFT_ROTATE(T, z)       // case 3
    T.root.color = BLACK                // root is black (case 0)


//===============================================
 Transplant for red-black trees.
//===============================================
RB_TRANSPLANT(T, u, v)
    if u.p == T.nil         // nothing to replace
        T.root = v          // u is root of T, replace it with v
    else if u == u.p.left
        u.p.left = v        // u is a left subtree, replace it with v
    else
        u.p.right = v       // u is a right subtree, replace it with v
    v.p = u.p               // link v to u's parent, replacement complete

//===============================================
 Delete.
//===============================================
RB_DELETE(T, z)
    y = z
    y_original_color = y.color
    if z.left == T.nil
        x = z.right
        RB_TRANSPLANT(T, z, z.right)
    
    else if z.right == T.nil
        x = z.left
        RB_TRANSPLANT(T, z, z.left)
    
    else
        y = TREE_MINIMUM(z.right)
        y_original_color = y.color
        x = y.right
        
        if y.p == z
            x.p = y
        else
            RB_TRANSPLANT(T, y, y.right)
            y.right = z.right
            y.right.p = y
        
        RB_TRANSPLANT(T, z, y)
        y.left = z.left
        y.left.p = y
        y.color = z.color
    if y_original_color == BLACK
        RB_DELETE_FIXUP(T, x)


//-----------------------------------------------
 Delete fixup procedure.
//-----------------------------------------------
RB_DELETE_FIXUP(T, x)
    while x != T.root and x.color == BLACK
        if x == x.p.left
            w = x.p.right
            
            if w.color == RED
                w.color = BLACK         // case 1
                x.p.color = RED         // case 1
                LEFT_ROTATE(T, x.p)     // case 1
                w = x.p.right           // case 1
            
            if w.left.color == BLACK and w.right.color == BLACK
                w.color = RED           // case 2
                x = x.p                 // case 2
            
            else if w.right.color == BLACK
                w.left.color = BLACK    // case 3
                w.color = RED           // case 3
                RIGHT_ROTATE(T, w)      // case 3
                w = x.p.right           // case 3
            w.color = x.p.color         // case 4
            x.p.color = BLACK           // case 4
            LEFT_ROTATE(T, x.p)         // case 4
            x = T.root                  // case 4
            
        // x == x.p.right
        else
            w = x.p.left
            
            if w.color == RED
                w.color = BLACK         // case 1
                x.p.color = RED         // case 1
                RIGHT_ROTATE(T, x.p)    // case 1
                w = x.p.left            // case 1
            
            if w.right.color == BLACK and w.left.color == BLACK
                w.color = RED           // case 2
                x = x.p                 // case 2
            
            else if w.left.color == BLACK
                w.right.color = BLACK   // case 3
                w.color = RED           // case 3
                LEFT_ROTATE(T, w)       // case 3
                w = x.p.left            // case 3
            w.color = x.p.color         // case 4
            x.p.color = BLACK           // case 4
            RIGHT_ROTATE(T, x.p)        // case 4
            x = T.root                  // case 4
    x.color = BLACK
