//***********************************************
 Huffman codes notes.
//***********************************************

- Huffman codes compress data, in the range of 20%-90% of space is saved.

- Huffman's greedy algorithm uses a table giving how often each character occurs (i.e. its frequency) to build up an optimal way of representing each character as a binary string.

- From the book, unique binary strings represent each character--binary character code, which we call a codeword.
    - Fixed-length code: will use up more bits than needed for characters that have zeros at the end of the string.
    
    - Variable length code: uses less space.

* Prefix codes (or, perhaps using "prefix-free codes" is a better name): codes in which no code is prefix for another codeword.
    - This means every character is uniquely identified by a binary string (of varying lengths).
    - To encode data, all that is needed is to concatenate the strings.
    
    ex: 
        a = 0
        b = 101
        e = 1101
        
        using * to concatenate
        
        aabe = 0*0*101*1101
    
    - The decoding process can be represented by binary tree whose leaves are the given characters.
        - Interpret the binary codeword for a character as the simple path from the root to that character, where
            0 means "go left"
            1 means "go right"
        - Leaves are labeled, along with the character, the frequency of that character in the sequence.
        - Internal nodes' numbers are just these frequencies added, up to 100%.
        
        ex:
                    100
                  0/   \1
                a:45   _55___
                     0/      \1
                   __25       30_
                 0/    \1   0/   \1
              c:12    b:13  /    d:16
                           14
                         0/  \1
                       f:5    e:9
            
            Tree corresponds to optimal prefix codes: a = 0, b = 101, ..., f = 1100

//-----------------------------------------------
// Huffman pseudo code.
// Running time:    O(n lg n)
// Purpose: build a binary tree like the one above given characters and their frequencies, this method returns the root of that tree. This builds in a bottom-up manner.
//-----------------------------------------------
#DEFINE c   // character object having attribute c.freq giving its frequency
#DEFINE C   // set of n characters
#DEFINE Q   // min-priority queue

HUFFMAN(C)
    n = C.size  // get size of character in list C
    Q = C       // can initialize Q using BUILD_MIN_HEAP() procedure
    for i = 1 to n-1
        allocate a new node z
        z.left = x = EXTRACT_MIN(Q)
        z.right = y = EXTRACT_MIN(Q)
        
        // Merge the two least common sequences, this wil form the internal nodes of the tree, the nodes will remain as leafs.
        z.freq = x.freq + y.freq
        INSERT(Q, z)
    return EXTRACT_MIN(Q)   // return the root of the tree
