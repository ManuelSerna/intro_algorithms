//*********************************************** 
// Rod cutting problem
//***********************************************

- This section examines the problem of cutting a rod into rods of smaller length in way that maximizes their total value (profit).


- For i = 1, 2, ..., the price pi in dollars is given.
    - The rod-cutting problem is the following. Given a rod of length n inches and a table of prices pi for i = 1, 2, ...,  n, determine the maximum revenue rn obtainable by cutting up the rod and selling the pieces. Note that if the price pn for a rod of length n is large enough, an optimal solution may require no cutting at all.

- A rod of length n can be cut in 2^(n-1) different ways.

//===============================================
/*
    Recursive top-down implementation--a problem is that the recursive calls to CUT_ROD occur often with the same values, this reduces efficiency.    
    - Every time we increase n by 1 (ONE!!!), the run time approximately doubles. Growth is explosive.
    
    
    - Inputs:
        p --array [1..n] of prices
        n --length of rod
    - Returns: 
        q --maximum revenue
*/
//===============================================
CUT_ROD(p, n)
    if n == 0
        return 0
    q = -(infinity)
    for i = 1 to n
        q = max(q, p[i] + CUT_ROD(p, n-1))
    return q

//===============================================

- To use dynamic programming to solve this problem, we modify our method to solve unique subproblems only once. We store this solution for easy look-up later when needed.

-Dynamic programming thus uses additional memory to save computation time; it serves an example of a time-memory trade-off. The savings may be dramatic: an exponential-time solution may be transformed into a polynomial-time solution. A dynamic-programming approach runs in polynomial time when the number of distinct subproblems involved is polynomial in the input size and we can solve each such subproblem in polynomial time.

* Two equivalent ways to implement a dynamic programming approach.
    - Top-down with memoization:
        - Write procedure recursively but save new subproblems in an array or hash table. The procedure checks if the subproblem has already been solved, if so, it returns the saved value.
        - We say that the recursive procedure has been memoized; it “remembers” what results it has computed previously.

    
    - Bottom-up method:
        - This approach typically depends on some natural notion of the "size" of a subproblem, such that solving any particular subproblem depends only on solving "smaller" subproblems.
            - Sort the subproblems by size, from smallest to biggest.
            -  When solving a particular subproblem, we have already solved all of the smaller subproblems its solution depends upon, and we have saved their solutions. 

* These two approaches yield algorithms with the same asymptotic running time, except in unusual circumstances where the top-down approach does not actually recurse to examine all possible subproblems. The bottom-up approach often has much better constant factors, since it has less overhead for procedure calls.

//-----------------------------------------------
// Pseudocode for top-down CUT_ROD procedure, with memoization added
// Run time: O(n^2)
//-----------------------------------------------

// This procedure starts the top-down procedure by initializing a new array r[0..n] with -(infinity) serving as an "unknown"
MEMOIZED_CUT_ROD(p, n)
    let r[0..n] be a new array
    for i = 0 to n
        r[i] = -(infinity)
    return MEMOIZED_CUT_ROD_AUX(p, n, r)

// Memoized version of original CUT_ROD method
MEMOIZED_CUT_ROD_AUX(p, n, r)
    if r[n] >= 0    // is desired value already known?
        return r[n]
    if n == 0       // bottom out
        q = 0
    else            // compute desired value
        q = -(infinity)
        for i = 1 to n
            q = max(q, p[i] + MEMOIZED_CUT_ROD_AUX(p, n-i, r))
    
    r[n] = q        // store max profit
    return q


//-----------------------------------------------
// Bottom-up version of CUT_ROD
/*
    BOTTOM_UP_CUT_ROD uses the natural ordering of the subproblems: a problem of size i is “smaller” than a subproblem of size j if i < j. Thus, the procedure solves subproblems of sizes j = 0, 1, ..., n, in that order.

    Run time: O(n^2) due to nested loop
*/
//-----------------------------------------------
BOTTOM_UP_CUT_ROD(p, n)
    let r[0..n] be a new array  // save results of subproblems
    r[0] = 0        // rod of length 0 earns no revenue
    for j = 1 to n
        q = -(infinity)
        for i = 1 to j
            q = max(q, p[i] + r[j-i])   // get result from subproblem
        r[j] = q    // solve subproblem of size j
    return r[n]

//-----------------------------------------------
- So far the procedures only return the VALUE of the optimal solution, not an actual solution: a list of piece sizes.

- We can extend the dynamic-programming approach to record not only the optimal value computed for each subproblem, but also a choice that led to the optimal value. With this information, we can readily print an optimal solution.

Extended version of BOTTOM_UP_CUT_ROD: 
     computes, for each rod size j , not only the maximum revenue r[j], but also s[j], the optimal size of the first piece to cut off
//-----------------------------------------------

EXTENDED_BOTTOM_UP_CUT_ROD(p, n)
    let r[0..n] and s[0..n] be new arrays
    r[0] = 0        // rod of length 0 earns no revenue
    for j = 1 to n
        q = -(infinity)
        for i = 1 to j
            if q < p[i] + r[j-i]
                q = p[i] + r[j-i]
                s[j] = i    //  hold the optimal size i of the first piece to cut off when solving a subproblem of size j
        r[j] = q
    return r and s


PRINT_CUT_ROD_SOLUTION(p, n)
    (r, s) = EXTENDED_BOTTOM_UP_CUT_ROD(p, n)
    while n > 0
        print s[n]
        n = n - s[n]


//-----------------------------------------------
example: EXTENDED_BOTTOM_UP_CUT_ROD(p, 10) would print

i     | 0   1   2   3   4   5   6   7   8   9   10
------+-------------------------------------------
r[i]  | 0   1   5   8   10  13  17  18  22  25  30
s[i]  | 0   1   2   3   2   2   6   1   2   3   10
